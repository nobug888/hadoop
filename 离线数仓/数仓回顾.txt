1、数据仓库概述
	1、什么是数仓
		数仓就是数据仓库,负责数据的存储、管理、分析
	2、数据仓库的架构
		日志数据->磁盘->flume[每台日志服务器一个flume]->kafka->Flume->
																		->HDFS->Hive[ODS/DWD+DIM/DWS/ADS]->datax->mysql->可视化
		业务数据->mysql->全量[datax]/增量[maxwell]导入->
		导入HDFS中日志格式:
			页面日志: { "common":{....},"actions":[ {...},{....} ],"displays":[ {....},{...} ],"page":{....},"ts":... }
			启动日志: { "common":{....}, "start":{....} , "ts": ...}
		导入HDFS中业务数据格式:
			全量导入: 普通文本,mysql字段之间通过特定分隔符分割
				导入逻辑: 每天将mysql表中所有数据全部导入到HDFS
				适用场景: 表数据量小/表数据量大但是每天变更数据特别大
			增量导入: 
				导入逻辑: 第一次导入的时候是将表中所有数据导入HDFS中,后续每天只需要导入当天新增和修改的数据。
				适用场景: 表数据量大但是每天变更频率比较小
				insert操作: { "database":..., "tableName":..., "type":"insert","data":{....}}
				update操作: { "database":..., "tableName":..., "type":"update","data":{....},"old":{...}}
				delete操作: { "database":..., "tableName":..., "type":"delete","data":{....}}
2、数据仓库建模概述
	1、数仓建模
		数仓建模: 将数据有序的存储与管理[其实就是建表]
		模型: 将数据有序的存储与管理的方法[其实就是指导建表的方法]
	2、建模常用模型
		ER模型: 以实体关系的形式描述业务,以规范化形式表示,需要遵循3NF
			实体: 其实就是对象
			关系: 表示表之间的从属关系[1对1,1对N,N对N]
			ER模型的优点: 能够降低数据冗余,增强数据一致性
			ER模型的缺点: ER模式会将一个表拆分为多个表,后续查询数据的时候需要多表join,效率会降低
			三范式
				1、第一范式: 属性不可切分
				2、第二范式: 非主键字段不能部分依赖主键字段
				3、第三范式: 非主键字段不能传递依赖主键字段
			ER模式不适合做数据分析,一般用于关系型数据库建模
		维度模型: 以事实和维度描述业务
			事实: 围绕业务过程设计的就是事实
			维度: 事实发生的环境的描述[何人、何时、何地]
			数仓建模适合用于数据分析,工作一般选用维度建模
			维度模型优点: 采用不规范化的方式建表,会将多个表合并成一个表,便于后续查询,查询效率比较高
			维度模型缺点: 数据冗余
3、维度建模之事实表
	1、事实表概述
		1、什么是事实表: 
			围绕业务过程设计的就是事实表
			事实表中一般存放两种类型的字段: 维度外键、度量值[度量值一般是数字]
		2、事实表特点
			事实表特点:列少,行多
		3、事实表分类
			事务型事实表
			周期快照型事实表
			累积快照型事实表
	2、事务型事实表
		定义: 记录业务过程最细粒度操作的表称之为事务型事实表
		设计流程: 选择业务过程->声明粒度->确定维度->确定事实
			选择业务过程[选择创建哪些事实表]: 选择后续需求需要用到的或者可能会用到的业务过程[一个业务过程对应一张事务型事实表]
			声明粒度[确定表中每行保存啥]: 选择最细粒度以满足后续该业务过程所有的业务需求
				粒度: 一行数据的表述的意思
			确定维度[确定表有哪些列]: 选择业务过程所关联的维度,维度尽可能丰富,维度越丰富后续的可统计的指标才会越丰富
			确定事实[确定表有哪些列]: 事实就是度量值,度量值一般是数字
		不足: 对于存量型指标、多事务关联指标的计算效率比较低【需要多张事务型事实表join操作,性能比较低】
	3、周期型快照事实表
		定义: 以固定周期记录业务过程结果的就是周期型快照事实表
		周期型快照事实表只有特定的需求的才会创建
		适用场景: 周期型快照事实表主要用于统计存量型指标[银行卡余额]、状态型指标[速度、温度]
		设计流程: 声明粒度 -> 确定事实
			声明粒度:
				周期型快照事实表粒度由周期+维度决定
				周期型快照事实表的记录周期一般是一天一次
				维度由需求决定
			确定事实:
				事实有需求决定
		事实类型[度量的类型]: 
			可加事实: 表中所有维度累加都有意义的事实称之为可加事实[事务型事实表的事实]
			半可加事实: 表中部分维度累加都有意义的事实称之为半可加事实[周期型快照事实表的事实]
			不可加事实[比例事实]: 事实不能累加的
				不可加事实需要转换成可加事实
	4、累积型快照事实表
		定义: 记录一个业务流程中多个业务过程操作的表称之为累积型快照事实表
		累积型快照事实表只有特定的需求的才会创建
		适用场景: 一般用于记录一个业务流程中多个业务过程的时间间隔等需求
		设计流程: 选择业务过程->声明粒度->确定维度->确定事实
			选择业务过程: 选择流程中需要的多个业务过程,多个业务过程对应一张累积型快照事实表
			声明粒度: 选择最细粒度
			确定维度: 选择多个业务过程对应的所有维度,还需要给每个业务过程加上一个时间维度
			确定事实: 选择多个业务过程对应的所有事实
4、维度建模之维度表
	1、维度表概述: 维度是事实发生的环境描述,维度表中有维度主键和维度字段[维度属性]
	2、维度表设计步骤
		1、确定维度
			一般事实表中一个维度对应一张维度表
			如果多个事实有相同的维度,此时只需要创建一个公共的维度表即可
			如果一个维度表的维度属性比较少,此时不需要建表,将维度值直接放在事实表维度字段中[维度退化]
		2、确定主维表和相关维表
			主维表和相关维表是在维度表在业务中相关的表
			维度表的粒度与主维表的粒度一致
		3、确定维度属性
			维度属性一般从主维表和相关维表直接获取或者通过一定的加工得到
			维度属性选择需要遵循的原则:
				1、尽可能丰富
				2、不要只保存编码,尽量用文字描述,可以编码和文字共存
				3、沉淀通用的维度
	3、维度表的设计要点
		1、规范化与反规范化
			规范化: 遵循范式设计表[将一个表拆分为多个表]
				优点: 减少数据冗余,增强一致性
				缺点: 后续分析的时候需要表Join,查询性能比较低
			反规范化： 不遵循范式设计表[将多个表合并成一个表]
				优点: 适合用于数据分析,性能相对比较高
				缺点: 数据冗余
			遵循规范化设计称之为雪花模型
			遵循非规范化设计称之为星型模型[工作中一般为星型模型]
		2、维度变化
			维度表的数据不是一成不变的,是可能随着时间的变化而变化。
			数仓是可以保存历史数据
			维度表数据变化的时候,历史数据的保存策略:
				全量快照表
					定义: hive表每个分区中保存每天表中所有数据的称之为全量快照表
					适用场景: 表的数据量小或者表数据量大并且变化频率很大
					优点: 使用简单、同步简单
					缺点: 数据冗余[当数据量很大的时候,变化频率比较小的时候,如果采用全量同步,hive表每个分区中存在大量的重复数据]
					使用
						1、查询最新数据: 只需要查询最新分区即可
						2、查询某天历史数据: 只需要查询当前分区即可
				拉链表
					定义: 记录每条数据生命周期的表称之为拉链表,拉链表的数据一般都有两个日期[生效日期,失效日期]
						如果数据是最新数据,则该数据的失效日期是一个极大值[9999-12-31]
						如果数据被修改,则旧数据的失效日期改为修改日期前一天,新数据的生效日期为修改日期,失效日期为极大值[9999-12-31]
					适用场景: 表数据量大并且变化频率低[缓慢变化维]
					使用
						1、查询最新数据: select .. from .. where 失效日期='9999-12-31'
						2、查询历史数据: select ... from .. where 生效日期<='指定日期' and '指定日期'<='9999-12-31'
		3、多值维度:事实表一条数据对应维度表多条数据
			解决方案:
				1、降低事实表粒度
				2、在事实表中创建多个字段,每个字段保存一个维度值【只能用于维度个数固定的情况】
				3、在事实表中创建一个特殊类型字段[数组、map类型字段]保存多个维度值【用于维度个数不固定的情况】
		4、多值属性: 维度表中一个纬度属性有多个值
			解决方案:
				1、在维度表中多创建几个字段,每个保存一个值【只能用于维度个数固定的情况】
				2、在维度表中创建一个字段特殊类型字段[数组、map类型字段]保存多个维度值【用于维度个数不固定的情况】
5、数据仓库设计
	1、数仓分层
		ODS: 原始数据层[保存的是没有任何操作的原始数据]
		DWD: 数据明细层[保存是各种事实表]
		DIM: 公共维度维度[保存是各种维度表]
		DWS: 公共汇总层[保存是多个指标共同的汇总数据]
		ADS: 数据应用层[保存的是指标结果]
		好处:
			1、目标更明确
			2、实现数据的复用,减少数据的重复计算
			3、屏蔽原始数据,避免原始数据的污染
	2、数仓构建的流程
														->构建业务矩阵->构建维度模型[DWD+DIM]
		数据调研[业务调研+需求分析] -> 区分数据作用域 											->开发->调度
														->构建指标体系->构建公共汇总[DWS]
	3、数据调研
		业务调研
			熟悉业务: 熟悉每个业务过程
			熟悉业务数据: 知道每个业务过程对数据的影响[新增数据/修改数据]
		需求分析
			确保每个需求都能找到业务过程和维度
	4、区分数据作用域
		在数仓每一层中对数据进行分类,便于后续数据查询
		每个表只能属于一个作用域
		区分作用域没有固定标准,好用即可[后续能够快速找到数据]
	5、构建业务矩阵
		通过业务调研熟悉每个业务过程,最终形成一个行列的表格。
			每个业务过程为一行
			每个维度为一列
			行与列的交叉位置代表维度和业务过程的关系[交叉位置如果打上勾勾,代表业务过程与维度有关系]
			通过业务矩阵就可以知道需要创建哪些事务型事实表与维度表。
	6、构建指标体系
		指标体系相关概念:
			1、原子指标: 原子指标有三个要素[业务过程、度量值、度量值的聚合逻辑]
				原子指标没有直接的需求对应
			2、派生指标 = 原子指标 + 统计周期 + 业务限定 + 统计粒度
			3、衍生指标 = 多个派生指标计算得到
		指标体系构建的好处: 分析的需求足够多的时候会发现多个需求会用到同一个派生指标,此时可以将多个需求共同的派生指标先求得结果保存在DWS层表中,后续需求要用的时候可以直接查询使用,避免了数据的重复计算。
		当业务过程一样、统计周期一样、统计粒度一样的多个派生指标可以保存在一个DWS表中
	7、构建维度模型: 根据业务矩阵创建事实表与维度表
	8、构建公共汇总: 分析需求构建指标体系创建
6、ODS层
	ODS建表
		1、建多少表: 有多种数据就建多少张表
		2、表名定义规范: ODS_表名_全量[full]/增量[inc]标识
		3、建内部表还是外部表
			内部表: 在删除hive表的时候会删除表元数据以及表HDFS数据
			外部表: 在删除hive表的时候只会删除表元数据
			工作中一般都是使用外部表
		4、表结构如何设计[字段个数]、表的行格式化方式设置为啥、存储格式设置为啥
			1、如果HDFS数据是普通文件
				1、如果文件中字段之间是固定分隔符的
					表的字段数与文件中字段数对应即可
					表的列名自己定义,根据文件中字段的含义取名,列名最好见名知意
					行格式: row format delimited fields terminated by '分隔符'
					存储格式: stored as textfile
				2、如果文件中数据是json
					1、表只有一个列,列中就保存一整个json数据,后续可以使用get_json_object取出json中属性的值
						行格式: 保持默认即可
						存储格式: stored as textfile
					2、表的列名与json一级属性名一致
						行格式: ROW FORMAT SERDE 'org.apache.hadoop.hive.serde2.JsonSerDe'
						存储格式: stored as textfile
				3、如果文件是csv文件
					表的字段数与文件中字段数对应即可
					表的列名自己定义,根据文件中字段的含义取名,列名最好见名知意
					行格式: ROW FORMAT SERDE'org.apache.hadoop.hive.serde2.OpenCSVSerde' 
					存储格式: stored as textfile
			2、如果HDFS数据不是普通文件,是orc/parquet等文件
				表的列名必须与文件中列名一致
				行格式: 保持默认即可
				存储格式: stored as parquet/orc
		5、分区设计: 工作中一般按天分区
		6、表数据存放HDFS位置
			如果数仓是刚开始,还没有创建任何表,此时表数据存放HDFS路径由你指定,后续所有表路径保持一致即可
			如果数仓已经有表创建了,此时表数据存放HDFS路径与原来表的路径保持一致
		7、是否压缩: 要
		8、使用哪种压缩格式
			ODS数据量大选用压缩比较高[gzip]
		9、表数据从哪里加载
			数据从HDFS时间目录获取
		10、数据加载到哪里去
			数据加载到ODS当天分区中
		11、数据加载方式
			load data inpath '....' overwrite into table 表名 partition(分区字段名=当天)
	hive复杂数据类型
		array
			类型定义: ARRAY<元素类型>
			构建array类型数据: array(元素,....)
			使用: 字段名[角标]
		map
			类型定义: MAP<K的类型,V的类型>
			构建map类型数据: map(k1,v1,k2,v2,...)
			使用: 
				1、根据key获取value值: 字段名[key]
				2、获取所有key: map_keys(字段名)
				3、获取所有value: map_values(字段名)
		struct
			类型定义: STRUCT<属性名:属性类型,...>
			构建struct类型数据: 
				1、struct(属性值,....) [此种方式属性名是默认的,默认为colN]
				2、named_struct(属性名,属性值,属性名,属性值,...)
			使用: 
				1、根据key获取value值: 字段名[key]
				2、获取所有key: map_keys(字段名)
				3、获取所有value: map_values(字段名)
7、DIM层
	DIM建表
		1、建多少表: 有业务矩阵决定
			业务矩阵每一列就是一个维度,一般对应一个维度表
			如果维度属性很少,该维度不用创建维度表,直接退化到事实表中
			维度表个数 = 业务矩阵的维度列个数 - 退化的维度个数
		2、表名定义规范: dim_表名_全量[full]/拉链[zip]标识
		3、建内部表还是外部表
			内部表: 在删除hive表的时候会删除表元数据以及表HDFS数据
			外部表: 在删除hive表的时候只会删除表元数据
			工作中一般都是使用外部表
		4、表结构如何设计[字段个数]
			维度表的行: 粒度与主维表保持一致
			维度表的列: 从维度相关的主维表和相关维表直接获取或者加工计算得到。
				维度属性选择遵循的原则
					1、维度尽可能丰富[还要选择有意义的维度]
					2、不能只有编码,应该编码和文字共存
					3、沉底通用的维度
		5、表的行格式化方式设置为啥
			保持默认即可
		6、存储格式设置为啥
			DIM与DWD层会经常查询数据,所以数据在保存的文件格式选择查询速度快的文件格式。
			所以一般采用列存储格式[orc、parquet]
			stored as orc/parquet
		7、分区设计: 工作中一般按天分区
		8、表数据存放HDFS位置
			如果数仓是刚开始,还没有创建任何表,此时表数据存放HDFS路径由你指定,后续所有表路径保持一致即可
			如果数仓已经有表创建了,此时表数据存放HDFS路径与原来表的路径保持一致
		9、是否压缩: 要
		10、使用哪种压缩格式:DIM选用速度快的压缩[snappy]
		11、表数据从哪里加载
			全量快照表: 每次hive一个分区存放当天表中所有数据
				全量快照表的数据从ODS层表当天分区获取
			拉链表
				首日: 从ODS层表当天分区获取
				每日: 从ODS层表当天分区 + 9999-12-31分区数据
			dim的压缩选用速度比较快的压缩[snappy]
		12、数据加载到哪里去
			全量快照表: 加载到DIM层当天分区
			拉链表
				首日: 直接加载到9999-12-31分区中
				每日: 最新加载到9999-12-31分区中,失效数据放入 当日-1 日期分区中
		13、数据加载方式
			insert overwrite table 表名 select ... form  ....
8、DWD层
	DIM建表
		1、建多少表: 有业务矩阵决定
			业务一行建一个事务型事实表
			周期型快照事实表与累积型快照事实表由需求决定
		2、表名定义规范: dwd_作用域_表名_增量[inc]/全量[full]标识
			周期型快照事实表每个分区存放当天所有数据[full]
			事务型事实表与累积型快照事实存放的是当天发生的事实数据[inc]
		3、建内部表还是外部表
			内部表: 在删除hive表的时候会删除表元数据以及表HDFS数据
			外部表: 在删除hive表的时候只会删除表元数据
			工作中一般都是使用外部表
		4、表结构如何设计[字段个数]
			表的行粒度: 最细粒度
			表的列: 3w[何人、何时、何地] + 需求需要的维度 + 度量值
		5、表的行格式化方式设置为啥
			保持默认即可
		6、存储格式设置为啥
			DIM与DWD层会经常查询数据,所以数据在保存的文件格式选择查询速度快的文件格式。
			所以一般采用列存储格式[orc、parquet]
			stored as orc/parquet
		7、分区设计: 工作中一般按天分区
		8、表数据存放HDFS位置
			如果数仓是刚开始,还没有创建任何表,此时表数据存放HDFS路径由你指定,后续所有表路径保持一致即可
			如果数仓已经有表创建了,此时表数据存放HDFS路径与原来表的路径保持一致
		9、是否压缩: 要
		10、使用哪种压缩格式:DWD选用速度快的压缩[snappy]
		11、表数据从哪里加载
			周期型快照事实表: 从ODS层表当天分区获取
			事务型事实表/累积型快照事实表: 一般是从ODS表当天分区获取
		12、数据加载到哪里去
			周期型快照事实表: 加载到DWD层当天分区
			事务型事实表/累积型快照事实表: 哪天发生的事实就放入哪天分区中
		13、数据加载方式
			insert overwrite table 表名 select ... form  ....